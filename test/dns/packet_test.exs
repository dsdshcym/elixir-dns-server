defmodule DNS.PacketTest do
  use ExUnit.Case, async: true

  alias DNS.Packet

  describe "parse/1 header section" do
    test "parses header" do
      query =
        <<0x86, 0x2A, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67,
          0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01,
          0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00, 0x04, 0xD8, 0x3A,
          0xD3, 0x8E>>

      assert match?(
               %{
                 header: %{
                   id: 0x862A,
                   recursion_desired: true,
                   truncated_message: false,
                   authoritative_answer: false,
                   operation_code: 0,
                   query_response: true,
                   reserved: 0,
                   response_code: 0,
                   recursion_available: true,
                   question_count: 1,
                   answer_count: 1,
                   authority_count: 0,
                   additional_count: 0
                 }
               },
               Packet.parse(query)
             )
    end
  end

  describe "parse/1 question section" do
    test "parses one question" do
      query =
        <<0x86, 0x2A, 0x81, 0x80, 0, 1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F,
          0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0xC0,
          0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00, 0x04, 0xD8, 0x3A, 0xD3,
          0x8E>>

      assert match?(
               %{
                 questions: [
                   %{name: "google.com", type: :A}
                 ]
               },
               Packet.parse(query)
             )
    end

    test "parses multiple questions" do
      query =
        <<0x86, 0x2A, 0x81, 0x80, 0, 2, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F,
          0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x06,
          0x67, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00,
          0x01, 0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00, 0x04, 0xD8,
          0x3A, 0xD3, 0x8E>>

      assert match?(
               %{
                 questions: [
                   %{name: "google.com", type: :A},
                   %{name: "google.com", type: :A}
                 ]
               },
               Packet.parse(query)
             )
    end
  end

  describe "parse/1 answer section" do
    test "parses one answer" do
      query =
        <<0x86, 0x2A, 0x81, 0x80, 0x00, 0x01, 0, 1, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F,
          0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0xC0,
          0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00, 0x04, 0xD8, 0x3A, 0xD3,
          0x8E>>

      assert match?(
               %{
                 answers: [
                   %{domain: "google.com", addr: {216, 58, 211, 142}, ttl: 293}
                 ]
               },
               Packet.parse(query)
             )
    end

    test "parses multiple answers" do
      query =
        <<0x86, 0x2A, 0x81, 0x80, 0x00, 0x02, 0, 2, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67, 0x6F,
          0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x06,
          0x67, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00,
          0x01, 0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00, 0x04, 0xD8,
          0x3A, 0xD3, 0x8E, 0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x25, 0x00,
          0x04, 0xD8, 0x3A, 0xD3, 0x8E>>

      assert match?(
               %{
                 answers: [
                   %{domain: "google.com", addr: {216, 58, 211, 142}, ttl: 293},
                   %{domain: "google.com", addr: {216, 58, 211, 142}, ttl: 293}
                 ]
               },
               Packet.parse(query)
             )
    end

    test "includes answer's type info" do
      answer =
        <<0x1F, 0x00, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x77,
          0x77, 0x77, 0x05, 0x62, 0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00,
          0x01, 0x00, 0x01, 0xC0, 0x0C, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x01, 0xE3, 0x00,
          0x0F, 0x03, 0x77, 0x77, 0x77, 0x01, 0x61, 0x06, 0x73, 0x68, 0x69, 0x66, 0x65, 0x6E,
          0xC0, 0x16, 0xC0, 0x2B, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0E,
          0x03, 0x77, 0x77, 0x77, 0x07, 0x77, 0x73, 0x68, 0x69, 0x66, 0x65, 0x6E, 0xC0, 0x16,
          0xC0, 0x46, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x00, 0x04, 0x67, 0xEB,
          0x2E, 0x27>>

      assert match?(
               %{
                 answers: [
                   %{type: :CNAME},
                   %{type: :CNAME},
                   %{type: :A}
                 ]
               },
               Packet.parse(answer)
             )
    end
  end

  describe "parse/1 authority section" do
    test "multiple authorities" do
      answer =
        <<0xB6, 0xDA, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x0C, 0x05, 0x7A,
          0x68, 0x69, 0x68, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0xC0,
          0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x14, 0x01, 0x65, 0x0C,
          0x67, 0x74, 0x6C, 0x64, 0x2D, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x03, 0x6E,
          0x65, 0x74, 0x00, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0x01, 0x62, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0x01, 0x6A, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x6D, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x69, 0xC0, 0x29, 0xC0, 0x12, 0x00,
          0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x66, 0xC0, 0x29, 0xC0,
          0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x61, 0xC0,
          0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01,
          0x67, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0x01, 0x68, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0x01, 0x6C, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x6B, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x63, 0xC0, 0x29, 0xC0, 0x12, 0x00,
          0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x64, 0xC0, 0x29, 0xC0,
          0x27, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x0C, 0x5E,
          0x1E, 0xC0, 0x27, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x10, 0x20,
          0x01, 0x05, 0x02, 0x1C, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x30, 0xC0, 0x47, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0,
          0x21, 0x0E, 0x1E, 0xC0, 0x47, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x10, 0x20, 0x01, 0x05, 0x03, 0x23, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x30, 0xC0, 0x57, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0xC0, 0x30, 0x4F, 0x1E, 0xC0, 0x57, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x02, 0x70, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x67, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0xC0, 0x37, 0x53, 0x1E, 0xC0, 0x67, 0x00, 0x1C, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x01, 0xB1, 0xF9, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x77, 0x00, 0x01, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x2B, 0xAC, 0x1E, 0xC0, 0x77, 0x00, 0x1C, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x03, 0x39, 0xC1, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x87, 0x00, 0x01, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x23, 0x33, 0x1E, 0xC0, 0x97, 0x00,
          0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x05, 0x06, 0x1E>>

      assert match?(
               %{
                 authorities: [
                   %{
                     domain: "com",
                     type: :NS,
                     ttl: 172_800,
                     host: "e.gtld-servers.net"
                   },
                   %{
                     domain: "com",
                     type: :NS,
                     ttl: 172_800,
                     host: "b.gtld-servers.net"
                   }
                   | _
                 ]
               },
               Packet.parse(answer)
             )
    end
  end

  describe "parse/1 additional section" do
    test "multiple additionals" do
      answer =
        <<0xB6, 0xDA, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x0C, 0x05, 0x7A,
          0x68, 0x69, 0x68, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0xC0,
          0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x14, 0x01, 0x65, 0x0C,
          0x67, 0x74, 0x6C, 0x64, 0x2D, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x03, 0x6E,
          0x65, 0x74, 0x00, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0x01, 0x62, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0x01, 0x6A, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x6D, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x69, 0xC0, 0x29, 0xC0, 0x12, 0x00,
          0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x66, 0xC0, 0x29, 0xC0,
          0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x61, 0xC0,
          0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01,
          0x67, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0x01, 0x68, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0x01, 0x6C, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x6B, 0xC0, 0x29, 0xC0, 0x12, 0x00, 0x02, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x63, 0xC0, 0x29, 0xC0, 0x12, 0x00,
          0x02, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0x01, 0x64, 0xC0, 0x29, 0xC0,
          0x27, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x0C, 0x5E,
          0x1E, 0xC0, 0x27, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x10, 0x20,
          0x01, 0x05, 0x02, 0x1C, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x30, 0xC0, 0x47, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0,
          0x21, 0x0E, 0x1E, 0xC0, 0x47, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x10, 0x20, 0x01, 0x05, 0x03, 0x23, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x30, 0xC0, 0x57, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00,
          0x04, 0xC0, 0x30, 0x4F, 0x1E, 0xC0, 0x57, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x02, 0x70, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x67, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0xA3,
          0x00, 0x00, 0x04, 0xC0, 0x37, 0x53, 0x1E, 0xC0, 0x67, 0x00, 0x1C, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x01, 0xB1, 0xF9, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x77, 0x00, 0x01, 0x00, 0x01, 0x00,
          0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x2B, 0xAC, 0x1E, 0xC0, 0x77, 0x00, 0x1C, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x10, 0x20, 0x01, 0x05, 0x03, 0x39, 0xC1, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x87, 0x00, 0x01, 0x00,
          0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x23, 0x33, 0x1E, 0xC0, 0x97, 0x00,
          0x01, 0x00, 0x01, 0x00, 0x02, 0xA3, 0x00, 0x00, 0x04, 0xC0, 0x05, 0x06, 0x1E>>

      assert match?(
               %{
                 additionals: [
                   %{
                     domain: "e.gtld-servers.net",
                     type: :A,
                     ttl: 172_800,
                     addr: {192, 12, 94, 30}
                   },
                   %{
                     domain: "e.gtld-servers.net",
                     type: :AAAA,
                     ttl: 172_800,
                     addr: {0x2001, 0x502, 0x1CA1, 0, 0, 0, 0, 0x30}
                   }
                   | _
                 ]
               },
               Packet.parse(answer)
             )
    end
  end

  describe "parse/1 integration" do
    test "query packet" do
      query =
        <<0x2A, 0xD0, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x67,
          0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01>>

      assert match?(
               %{
                 answers: [],
                 header: %{
                   additional_count: 0,
                   answer_count: 0,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 10960,
                   operation_code: 0,
                   query_response: false,
                   question_count: 1,
                   recursion_available: false,
                   recursion_desired: true,
                   reserved: 2,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "google.com", type: :A}]
               },
               Packet.parse(query)
             )
    end

    test "query baidu.com" do
      query =
        <<0x52, 0x99, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x62,
          0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01>>

      assert match?(
               %{
                 answers: [],
                 header: %{
                   additional_count: 0,
                   answer_count: 0,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 21145,
                   operation_code: 0,
                   query_response: false,
                   question_count: 1,
                   recursion_available: false,
                   recursion_desired: true,
                   reserved: 2,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "baidu.com", type: :A}]
               },
               Packet.parse(query)
             )

      answer =
        <<0x52, 0x99, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x62,
          0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0xC0,
          0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x34, 0x00, 0x04, 0x27, 0x9C, 0x45,
          0x4F, 0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x34, 0x00, 0x04, 0xDC,
          0xB5, 0x26, 0x94>>

      assert match?(
               %{
                 answers: [
                   %{addr: {39, 156, 69, 79}, domain: "baidu.com", ttl: 308},
                   %{addr: {220, 181, 38, 148}, domain: "baidu.com", ttl: 308}
                 ],
                 header: %{
                   additional_count: 0,
                   answer_count: 2,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 21145,
                   operation_code: 0,
                   query_response: true,
                   question_count: 1,
                   recursion_available: true,
                   recursion_desired: true,
                   reserved: 0,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "baidu.com", type: :A}]
               },
               Packet.parse(answer)
             )
    end

    test "support message compression when a domain name is represented as a sequence of labels ending with a pointer" do
      answer =
        <<0x52, 0x99, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x62,
          0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x05,
          0x62, 0x61, 0x69, 0x64, 0x75, 0xC0, 18, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x34,
          0x00, 0x04, 0x27, 0x9C, 0x45, 0x4F, 0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
          0x01, 0x34, 0x00, 0x04, 0xDC, 0xB5, 0x26, 0x94>>

      assert match?(
               %{
                 answers: [
                   %{addr: {39, 156, 69, 79}, domain: "baidu.com", ttl: 308},
                   %{addr: {220, 181, 38, 148}, domain: "baidu.com", ttl: 308}
                 ],
                 header: %{
                   additional_count: 0,
                   answer_count: 2,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 21145,
                   operation_code: 0,
                   query_response: true,
                   question_count: 1,
                   recursion_available: true,
                   recursion_desired: true,
                   reserved: 0,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "baidu.com", type: :A}]
               },
               Packet.parse(answer)
             )
    end

    test "support CNAME" do
      query =
        <<0x1F, 0x00, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x77,
          0x77, 0x77, 0x05, 0x62, 0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00,
          0x01, 0x00, 0x01>>

      assert match?(
               %{
                 answers: [],
                 header: %{
                   additional_count: 0,
                   answer_count: 0,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 7936,
                   operation_code: 0,
                   query_response: false,
                   question_count: 1,
                   recursion_available: false,
                   recursion_desired: true,
                   reserved: 2,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "www.baidu.com", type: :A}]
               },
               Packet.parse(query)
             )

      answer =
        <<0x1F, 0x00, 0x81, 0x80, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x77,
          0x77, 0x77, 0x05, 0x62, 0x61, 0x69, 0x64, 0x75, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00,
          0x01, 0x00, 0x01, 0xC0, 0x0C, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x01, 0xE3, 0x00,
          0x0F, 0x03, 0x77, 0x77, 0x77, 0x01, 0x61, 0x06, 0x73, 0x68, 0x69, 0x66, 0x65, 0x6E,
          0xC0, 0x16, 0xC0, 0x2B, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0E,
          0x03, 0x77, 0x77, 0x77, 0x07, 0x77, 0x73, 0x68, 0x69, 0x66, 0x65, 0x6E, 0xC0, 0x16,
          0xC0, 0x46, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x00, 0x04, 0x67, 0xEB,
          0x2E, 0x27>>

      assert match?(
               %{
                 answers: [
                   %{domain: "www.baidu.com", host: "www.a.shifen.com", ttl: 483},
                   %{domain: "www.a.shifen.com", host: "www.wshifen.com", ttl: 62},
                   %{addr: {103, 235, 46, 39}, domain: "www.wshifen.com", ttl: 118}
                 ],
                 header: %{
                   additional_count: 0,
                   answer_count: 3,
                   authoritative_answer: false,
                   authority_count: 0,
                   id: 7936,
                   operation_code: 0,
                   query_response: true,
                   question_count: 1,
                   recursion_available: true,
                   recursion_desired: true,
                   reserved: 0,
                   response_code: 0,
                   truncated_message: false
                 },
                 questions: [%{name: "www.baidu.com", type: :A}]
               },
               Packet.parse(answer)
             )
    end
  end

  describe "new_query/1 for one domain" do
    test "generates a random id" do
      %{header: %{id: id}} = Packet.new_query("example.com")

      assert id > 0
      assert id < 65536
    end

    test "sets query_response to false" do
      assert %{header: %{query_response: false}} = Packet.new_query("example.com")
    end

    test "sets operation_code to 0" do
      assert %{header: %{operation_code: 0}} = Packet.new_query("example.com")
    end

    test "sets recursion_desired to false" do
      assert %{header: %{recursion_desired: false}} = Packet.new_query("example.com")
    end

    test "sets question_count to 1" do
      assert %{header: %{question_count: 1}} = Packet.new_query("example.com")
    end

    test "pushes the domain into questions" do
      assert %{questions: [%{name: "example.com", type: :A}]} = Packet.new_query("example.com")
    end

    test "sets other fields to false or 0 or []" do
      assert %{
               header: %{
                 authoritative_answer: false,
                 truncated_message: false,
                 recursion_available: false,
                 reserved: 0,
                 response_code: 0,
                 answer_count: 0,
                 authority_count: 0,
                 additional_count: 0
               },
               answers: [],
               authorities: [],
               additionals: []
             } = Packet.new_query("example.com")
    end
  end

  describe "to_binary/1 header section" do
    test "sets ID correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531}}

      assert <<65531::16, _::bits>> = Packet.to_binary(packet)
    end

    test "sets QR correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, query_response: false}}
      assert <<_ID::16, 0::1, _::bits>> = Packet.to_binary(packet)

      packet = %Packet{header: %Packet.Header{id: 65531, query_response: true}}
      assert <<_ID::16, 1::1, _::bits>> = Packet.to_binary(packet)
    end

    test "sets Opcode correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, operation_code: 15}}
      assert <<_ID::16, _QR::1, 15::4, _::bits>> = Packet.to_binary(packet)
    end

    test "sets AA correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, authoritative_answer: false}}
      assert <<_ID::16, _QR::1, _Opcode::4, 0::1, _::bits>> = Packet.to_binary(packet)

      packet = %Packet{header: %Packet.Header{id: 65531, authoritative_answer: true}}
      assert <<_ID::16, _QR::1, _Opcode::4, 1::1, _::bits>> = Packet.to_binary(packet)
    end

    test "sets TC correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, truncated_message: false}}
      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, 0::1, _::bits>> = Packet.to_binary(packet)

      packet = %Packet{header: %Packet.Header{id: 65531, truncated_message: true}}
      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, 1::1, _::bits>> = Packet.to_binary(packet)
    end

    test "sets RD correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, recursion_desired: false}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, 0::1, _::bits>> =
               Packet.to_binary(packet)

      packet = %Packet{header: %Packet.Header{id: 65531, recursion_desired: true}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, 1::1, _::bits>> =
               Packet.to_binary(packet)
    end

    test "sets RA correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, recursion_available: false}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, _RD::1, 0::1, _::bits>> =
               Packet.to_binary(packet)

      packet = %Packet{header: %Packet.Header{id: 65531, recursion_available: true}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, _RD::1, 1::1, _::bits>> =
               Packet.to_binary(packet)
    end

    test "sets Z correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, reserved: 7}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, _RD::1, _RA::1, 7::3, _::bits>> =
               Packet.to_binary(packet)
    end

    test "sets RCODE correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, response_code: 15}}

      assert <<_ID::16, _QR::1, _Opcode::4, _AA::1, _TC::1, _RD::1, _RA::1, _Z::3, 15::4,
               _::bits>> = Packet.to_binary(packet)
    end

    test "sets QDCOUNT correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, question_count: 60000}}
      assert <<_::32, 60000::16, _::bits>> = Packet.to_binary(packet)
    end

    test "sets ANCOUNT correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, answer_count: 60001}}
      assert <<_::32, _QDCOUNT::16, 60001::16, _::bits>> = Packet.to_binary(packet)
    end

    test "sets NSCOUNT correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, authority_count: 60002}}
      assert <<_::32, _QDCOUNT::16, _ANCOUNT::16, 60002::16, _::bits>> = Packet.to_binary(packet)
    end

    test "sets ARCOUNT correctly" do
      packet = %Packet{header: %Packet.Header{id: 65531, additional_count: 60003}}

      assert <<_::32, _QDCOUNT::16, _ANCOUNT::16, _NSCOUNT::16, 60003::16, _::bits>> =
               Packet.to_binary(packet)
    end
  end

  describe "to_binary/1 question section" do
    test "one question" do
      packet = %Packet{
        header: %Packet.Header{id: 65531},
        questions: [%Packet.Question{name: "example.com", type: :A}]
      }

      assert <<_HEADER::96, 7, "example", 3, "com", 0, 1::16, 1::16>> = Packet.to_binary(packet)
    end

    test "multiple questions" do
      packet = %Packet{
        header: %Packet.Header{id: 65531},
        questions: [
          %Packet.Question{name: "example.com", type: :A},
          %Packet.Question{name: "test.example.com", type: :A}
        ]
      }

      assert <<_HEADER::96, 7, "example", 3, "com", 0, 1::16, 1::16, 4, "test", 7, "example", 3,
               "com", 0, 1::16, 1::16>> = Packet.to_binary(packet)
    end
  end

  describe "to_binary/1 answer section" do
    test "one A answer" do
      packet = %Packet{
        header: %Packet.Header{id: 65531},
        answers: [
          %{type: :A, ttl: 64321, domain: "example.com", addr: {192, 168, 1, 1}}
        ]
      }

      assert <<_HEADER::96, 7, "example", 3, "com", 0, 1::16, 0::16, 64321::16, 4::16, 192, 168,
               1, 1>> = Packet.to_binary(packet)
    end

    test "multiple various answers" do
      packet = %Packet{
        header: %Packet.Header{id: 65531},
        answers: [
          %{type: :A, ttl: 64321, domain: "example.com", addr: {192, 168, 1, 1}},
          %{type: :NS, ttl: 64321, domain: "example.com", host: "ns.example.com"},
          %{type: :CNAME, ttl: 64321, domain: "example.com", host: "cname.example.com"},
          %{
            type: :MX,
            ttl: 64321,
            domain: "example.com",
            preference: 5,
            exchange: "mail1.example.com"
          },
          %{
            type: :AAAA,
            ttl: 64321,
            domain: "example.com",
            addr: {0x2001, 0x502, 0x1CA1, 0, 0, 0, 0, 0x30}
          }
        ]
      }

      assert <<
               _HEADER::96,
               # A
               7,
               "example",
               3,
               "com",
               0,
               1::16,
               0::16,
               64321::16,
               4::16,
               192,
               168,
               1,
               1,
               # NS
               7,
               "example",
               3,
               "com",
               0,
               2::16,
               0::16,
               64321::16,
               16::16,
               2,
               "ns",
               7,
               "example",
               3,
               "com",
               0,
               # CNAME
               7,
               "example",
               3,
               "com",
               0,
               5::16,
               0::16,
               64321::16,
               19::16,
               5,
               "cname",
               7,
               "example",
               3,
               "com",
               0,
               # MX
               7,
               "example",
               3,
               "com",
               0,
               15::16,
               0::16,
               64321::16,
               21::16,
               5::16,
               5,
               "mail1",
               7,
               "example",
               3,
               "com",
               0,
               # AAAA
               7,
               "example",
               3,
               "com",
               0,
               28::16,
               0::16,
               64321::16,
               16::16,
               0x2001::16,
               0x0502::16,
               0x1CA1::16,
               0::16,
               0::16,
               0::16,
               0::16,
               0x30::16
             >> = Packet.to_binary(packet)
    end
  end
end
